/**
* @copyright 2025 - Max Beb√∂k
* @license MIT
*/
include "rsp.inc"

// some dummy defines to make it work without libdragon
#define RSPQ_BeginOverlayHeader ;
#define RSPQ_EndOverlayHeader ;
#define RSPQ_BeginSavedState ;
#define RSPQ_EndSavedState ;
#define RSPQ_EmptySavedState ;

#include "dmemLayout.h"

state {
  vec16 _DUMMY_;
}

/**
 * RSPL relies on some vector registers setup by 'rsp_queue.inc' in libdragon.
 * Replicate the setup here for the two shift and zero register values.
 *
 * This function is only run once per frame to reset things.
 * So perf inside here doesn't matter much.
 */
@NoReturn
function Main()
{
   undef VSHIFT; undef VSHIFT8;
  vec16<$v30> VSHIFT; // make writable
  vec16<$v31> VSHIFT8;

  // clean all regs to be zero, some SDF parts rely on that initial state
  asm("vxor $v00, $v00, $v00");
  asm("vxor $v01, $v01, $v01");
  asm("vxor $v02, $v02, $v02");
  asm("vxor $v03, $v03, $v03");
  asm("vxor $v04, $v04, $v04");
  asm("vxor $v05, $v05, $v05");
  asm("vxor $v06, $v06, $v06");
  asm("vxor $v07, $v07, $v07");
  asm("vxor $v08, $v08, $v08");
  asm("vxor $v09, $v09, $v09");
  asm("vxor $v10, $v10, $v10");
  asm("vxor $v11, $v11, $v11");
  asm("vxor $v12, $v12, $v12");
  asm("vxor $v13, $v13, $v13");
  asm("vxor $v14, $v14, $v14");
  asm("vxor $v15, $v15, $v15");
  asm("vxor $v16, $v16, $v16");
  asm("vxor $v17, $v17, $v17");
  asm("vxor $v18, $v18, $v18");
  asm("vxor $v19, $v19, $v19");
  asm("vxor $v20, $v20, $v20");
  asm("vxor $v21, $v21, $v21");
  asm("vxor $v22, $v22, $v22");
  asm("vxor $v23, $v23, $v23");
  asm("vxor $v24, $v24, $v24");
  asm("vxor $v25, $v25, $v25");
  asm("vxor $v26, $v26, $v26");
  asm("vxor $v27, $v27, $v27");
  asm("vxor $v28, $v28, $v28");
  asm("vxor $v29, $v29, $v29");
  asm("vxor $v30, $v30, $v30");
  asm("vxor $v31, $v31, $v31");

  u16 tmp = 0x8000;
  VSHIFT8.x = tmp; tmp >>= 1;
  VSHIFT8.y = tmp; tmp >>= 1;
  VSHIFT8.z = tmp; tmp >>= 1;
  VSHIFT8.w = tmp; tmp >>= 1;
  VSHIFT8.X = tmp; tmp >>= 1;
  VSHIFT8.Y = tmp; tmp >>= 1;
  VSHIFT8.Z = tmp; tmp >>= 1;
  VSHIFT8.W = tmp;

  VSHIFT = VSHIFT8 >>> 8;
  SHIFT_END:

  // SDF constants
  vec32<$v04> ONE = 1;

  vec32<$v06> SPHERE_RAD;
  SPHERE_RAD.x = 0.25;
  SPHERE_RAD.y = 0.075;
  SPHERE_RAD.z = 0.5;
  SPHERE_RAD.w = 0.5773;

  SPHERE_RAD.X = 2.5;
  SPHERE_RAD.Y = 0.2;

  SPHERE_RAD.Z = -0.25;
  SPHERE_RAD.W = -0.075;

  vec32<$v08> LERP_FACTOR;

  vec32<$v10> rayPosOrg;
  rayPosOrg.x = load(ZERO, DMEM_RAYPOS_X).x;
  rayPosOrg.y = load(ZERO, DMEM_RAYPOS_Y).x;
  rayPosOrg.z = load(ZERO, DMEM_RAYPOS_Z).x;

  rayPosOrg.X = rayPosOrg.x;
  rayPosOrg.Y = rayPosOrg.y;
  rayPosOrg.Z = rayPosOrg.z;

  //u32<$a0> dmemFbAddr = 0x1000;

  s32<$a0> RENDER_DIST = 11.0 << 16;
  s32<$a1> STOP_DIST   = 0.016 * 0xFFFF;
}

macro invSqrt0(vec32 out, vec32 in)
{
  asm_op("vrsqh", out:sint.x, VZERO.x);
  asm_op("vrsql", out:sfract.x, in:sfract.x);
  asm_op("vrsqh", out:sint.x, VZERO.x);
  //out.x = invert_half_sqrt(in).x;
}

macro invSqrt1(vec32 out, vec32 in)
{
  asm_op("vrsqh", out:sint.X, VZERO.X);
  asm_op("vrsql", out:sfract.X, in:sfract.X);
  asm_op("vrsqh", out:sint.X, VZERO.x);
  //out.X = invert_half_sqrt(in).X;
}

macro unsafeVSR8(vec32 out, vec32 in)
{
  asm_op("vmudm", out:sint,   in:sint,   VSHIFT8.W);
  asm_op("vmadl", out:sfract, in:sfract, VSHIFT8.W);
}

/**
 * SDF/Raymarch loops.
 * Each function is an entire raymarch loop using a specific SDF.
 * The code is duped to avoid costly branches inside.
 * Check 'raymarch.rspl' for the actual implementation.
 */
#define SDF_REPEAT 1

#define SDF_NAME Main
#define SDF_FUNC_MAIN 1
  #include "raymarch.rspl"
#undef SDF_FUNC_MAIN
#undef SDF_NAME

#define SDF_NAME Sphere
#define SDF_FUNC_SPHERE 1
  #include "raymarch.rspl"
#undef SDF_FUNC_SPHERE
#undef SDF_NAME

#define SDF_NAME Cylinder
#define SDF_FUNC_CYLINDER 1
  #include "raymarch.rspl"
#undef SDF_FUNC_CYLINDER
#undef SDF_NAME

#undef SDF_REPEAT

#define SDF_NAME Octa
#define SDF_FUNC_OCTA 1
  #include "raymarch.rspl"
#undef SDF_FUNC_OCTA
#undef SDF_NAME
